<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>First-Person Warrior MVP</title>
  <style>
    body { margin:0; overflow:hidden; font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Open Sans','Helvetica Neue',sans-serif; background:#000; }
    #blocker { position:absolute; inset:0; background:rgba(0,0,0,0.7); display:flex; justify-content:center; align-items:center; cursor:pointer; z-index:10; }
    #instructions { width:80%; max-width:600px; text-align:center; color:#fff; background:rgba(20,20,20,0.9); padding:20px; border-radius:15px; border:1px solid #444; cursor:default; }
    #instructions h2 { margin:0; font-size:2rem; color:#ffa500; }
    #instructions p { font-size:1.1rem; line-height:1.5; }
    .class-selection button { background:#ffa500; color:#000; border:none; padding:15px 30px; font-size:1.2rem; font-weight:bold; border-radius:10px; cursor:pointer; margin:10px; transition:background-color .2s, transform .2s; }
    .class-selection button:hover { background:#ffc864; transform:scale(1.05); }
    #crosshair { position:fixed; top:50%; left:50%; width:4px; height:4px; background:#fff; border-radius:50%; transform:translate(-50%,-50%); pointer-events:none; z-index:9; mix-blend-mode:difference; display:none; }
    #health-bar-container { position:fixed; bottom:20px; left:50%; transform:translateX(-50%); width:300px; height:30px; background:rgba(0,0,0,0.5); border:2px solid #fff; border-radius:15px; display:none; z-index:9; }
    #health-bar { width:100%; height:100%; background:linear-gradient(90deg, #ff4500, #ff8c00); border-radius:12px; transition:width 0.2s ease-in-out; }
    #health-text { position:absolute; inset:0; color:#fff; text-shadow:1px 1px 2px #000; font-weight:bold; line-height:30px; text-align:center; }
  </style>
</head>
<body>
  <div id="blocker">
    <div id="instructions">
      <div id="menu-content">
        <h2>Choisissez votre classe</h2>
        <div class="class-selection">
          <button id="btnWarrior">Guerrier</button>
          <button id="btnMage">Mage</button>
        </div>
        <div style="margin-top:12px">
          <input id="roomCode" placeholder="Code de room (ex: ABCD)" maxlength="12" />
          <button id="btnCreate">Créer</button>
          <button id="btnJoin">Rejoindre</button>
        </div>
        <p style="margin-top:20px;">Appuyez sur Échap pour changer de classe.</p>
      </div>
    </div>
  </div>
  <div id="crosshair"></div>
  <div id="health-bar-container">
      <div id="health-bar"></div>
      <div id="health-text">100 HP</div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    // === Supabase ===
    const SUPABASE_URL = 'https://ywxeflymtbyorqcirqiq.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl3eGVmbHltdGJ5b3JxY2lycWlxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg2NzkzNDIsImV4cCI6MjA3NDI1NTM0Mn0.mCucqm8nJ_c-ZaPR6ZpxZhF9qaufrphk4lLNpho728Y';
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    let channel = null;
    const myId = crypto.randomUUID();
    const peers = new Map();
    const peerAvatars = new Map();

    function randomCode(){ return Math.random().toString(36).slice(2,6).toUpperCase(); }
    
    function createRemotePlayerAvatar(data) {
        const { pos, playerClass } = data;
        const avatarGroup = new THREE.Group();
        
        const skinMaterial = new THREE.MeshStandardMaterial({ color: 0xdeb887 });
        const darkMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

        const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), skinMaterial);
        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.4), darkMaterial);
        const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.0, 0.3), darkMaterial);
        leftLeg.position.set(-0.25, -1.1, 0);
        const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.0, 0.3), darkMaterial);
        rightLeg.position.set(0.25, -1.1, 0);
        
        const body = new THREE.Group();
        body.add(head, torso, leftLeg, rightLeg);
        avatarGroup.add(body);
        
        if (playerClass === 'warrior') {
            const armorMaterial = new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.8, roughness: 0.4 });
            const helmet = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), armorMaterial);
            head.add(helmet);
            const chestplate = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.0, 0.5), armorMaterial);
            chestplate.position.y = 0.1; torso.add(chestplate);
            const pauldron = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const leftPauldron = new THREE.Mesh(pauldron, armorMaterial);
            leftPauldron.position.set(-0.5, 0.4, 0); torso.add(leftPauldron);
            const rightPauldron = new THREE.Mesh(pauldron, armorMaterial);
            rightPauldron.position.set(0.5, 0.4, 0); torso.add(rightPauldron);
            const sword = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.5, 0.2), new THREE.MeshStandardMaterial({ color: 0xc0c0c0 }));
            sword.name = 'sword'; sword.position.set(0.8, 0.3, 0.1); sword.rotation.z = -Math.PI / 16; torso.add(sword);
            const shield = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.2), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
            shield.name = 'shield'; shield.position.set(-0.8, 0.1, 0.1); shield.rotation.z = Math.PI / 16; torso.add(shield);
        } else if (playerClass === 'mage') {
            const robeMaterial = new THREE.MeshStandardMaterial({ color: 0x4a0d6a });
            const hat = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.8, 8), robeMaterial);
            hat.position.y = 0.5; head.add(hat);
            const robe = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.8, 1.8, 8), robeMaterial);
            robe.position.y = -0.3; torso.add(robe);
        }

        avatarGroup.position.set(pos.x, pos.y - PLAYER_HEIGHT + 1.1, pos.z);
        scene.add(avatarGroup);
        objects.push(avatarGroup); // Ajout pour la collision
        return { mesh: avatarGroup, lastAction: 'idle' };
    }

    async function joinRoom(code){
      peerAvatars.forEach(avatar => {
        scene.remove(avatar.mesh);
        objects = objects.filter(o => o !== avatar.mesh);
      });
      peerAvatars.clear();
      peers.clear();

      if (channel) await supabase.removeChannel(channel);

      channel = supabase.channel(`room:${code}`, { config: { presence: { key: myId } } });

      channel.on('presence', { event: 'leave' }, ({ leftPresences }) => {
        for (const pres of leftPresences) {
            const avatar = peerAvatars.get(pres.key);
            if (avatar) {
                scene.remove(avatar.mesh);
                objects = objects.filter(o => o !== avatar.mesh);
                peerAvatars.delete(pres.key);
            }
            peers.delete(pres.key);
        }
      });
      
      channel.on('broadcast', { event: 'hit' }, ({ payload }) => {
          if (payload.targetId === myId) {
              takeDamage(payload.damage);
          }
      });

      channel.on('broadcast', { event:'state' }, ({ payload }) => {
        const { id, pos, rot, playerClass, action } = payload;
        if (id === myId) return;

        peers.set(id, { pos, rot, playerClass, action });
        if (!peerAvatars.has(id)) {
          const avatarData = createRemotePlayerAvatar({ pos, playerClass });
          peerAvatars.set(id, avatarData);
        }
      });

      await channel.subscribe((status) => {
        if (status === 'SUBSCRIBED') channel.track({ id: myId, joinedAt: Date.now() });
      });
    }

    window.addEventListener('pagehide', async () => {
      try { if (channel) await supabase.removeChannel(channel); } catch {}
    });

    // === Three.js / jeu ===
    let scene, camera, renderer, controls;
    let playerVelocity = new THREE.Vector3();
    let playerDirection = new THREE.Vector3();
    let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false, canJump=false;
    let objects = [];
    let playerClass = null;
    let playerHealth = 100;

    // ... (variables de classe)
    let isAttacking=false, lastAttackTime=0, isBlocking=false, isDashing=false, lastDashTime=0;
    const attackCooldown=100, dashCooldown=1500;
    let activeFireballs=[], lastFireballTime=0, heldFireball=null, iceWall=null;
    const fireballCooldown=1000, iceWallCooldown=10000, iceWallDuration=5000, blinkCooldown=3000;
    let lastIceWallTime=0, lastBlinkTime=0;
    
    let swordGroup, rightArm, leftArm, shield, floor;
    let initialSwordRotation, initialLeftArmPosition, initialLeftArmRotation;

    const PLAYER_SPEED=60.0, PLAYER_HEIGHT=1.8, GRAVITY=30.0, JUMP_VELOCITY=10.0, DASH_STRENGTH=35.0, BLINK_DISTANCE=8.0;

    const clock = new THREE.Clock();
    const crosshair = document.getElementById('crosshair');
    const healthBarContainer = document.getElementById('health-bar-container');
    const healthBar = document.getElementById('health-bar');
    const healthText = document.getElementById('health-text');

    let lastSend = 0;

    init();
    animate();

    function init(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 0, 100);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.y = PLAYER_HEIGHT;

      renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); scene.add(ambientLight);
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
      dirLight.position.set(-50,50,50); dirLight.castShadow = true;
      dirLight.shadow.camera.top=20; dirLight.shadow.camera.bottom=-20; dirLight.shadow.camera.left=-20; dirLight.shadow.camera.right=20;
      scene.add(dirLight);

      controls = new PointerLockControls(camera, document.body);
      const blocker = document.getElementById('blocker');
      const menuContent = document.getElementById('menu-content');

      function setupMenuListeners(){
        document.getElementById('btnWarrior').addEventListener('click', (e)=>selectClass(e,'warrior'));
        document.getElementById('btnMage').addEventListener('click', (e)=>selectClass(e,'mage'));
      }

      function setupRoomListeners(){
        const roomInput = document.getElementById('roomCode');
        document.getElementById('btnCreate').addEventListener('click', async (e)=>{
          e.stopPropagation();
          const code = (roomInput.value || randomCode()).toUpperCase();
          await joinRoom(code);
          alert(`Room créée: ${code}`);
        });
        document.getElementById('btnJoin').addEventListener('click', async (e)=>{
          e.stopPropagation();
          const code = (roomInput.value || '').toUpperCase();
          if (!code) return alert('Entre un code de room.');
          await joinRoom(code);
          alert(`Rejoint room: ${code}`);
        });
      }

      setupMenuListeners();
      setupRoomListeners();

      blocker.addEventListener('click', (event) => { 
        if (event.target === blocker && playerClass) {
          controls.lock(); 
        }
      });

      controls.addEventListener('lock', () => {
        blocker.style.display = 'none';
        crosshair.style.display = 'block';
        healthBarContainer.style.display = 'block';
      });

      controls.addEventListener('unlock', () => {
        blocker.style.display = 'flex';
        crosshair.style.display = 'none';
        healthBarContainer.style.display = 'none';
        
        // On ne réaffiche le menu que si le joueur est mort
        if (playerHealth <= 0) {
            menuContent.innerHTML = `
              <h2>Vous êtes mort.</h2>
              <p>Choisissez une classe pour réapparaître.</p>
              <div class="class-selection">
                <button id="btnWarrior">Guerrier</button>
                <button id="btnMage">Mage</button>
              </div>
            `;
            setupMenuListeners();
        }
      });

      document.addEventListener('pointerlockerror', () => console.error('Pointer Lock Error'), false);

      scene.add(controls.getObject());
      createWorld();

      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      document.addEventListener('mousedown', onMouseDown);
      document.addEventListener('mouseup', onMouseUp);
      window.addEventListener('resize', onWindowResize);
      document.addEventListener('contextmenu', (e)=>e.preventDefault());
    }

    function selectClass(event, chosenClass){
      event.stopPropagation();
      playerClass = chosenClass;
      playerHealth = 100;
      updateHealthUI();
      cleanupPlayerModel();
      createPlayerModel(playerClass);

      const menuContent = document.getElementById('menu-content');
      menuContent.innerHTML = `
        <h2>Classe : ${chosenClass === 'warrior' ? 'Guerrier' : 'Mage'}</h2>
        <p style="font-size:1.5rem; margin-top:30px;">Cliquez pour commencer</p>
      `;
    }

    // ... (cleanupPlayerModel, createPlayerModel, createWorld)
    function cleanupPlayerModel(){
      if (rightArm){
        if (swordGroup) rightArm.remove(swordGroup);
        if (heldFireball) rightArm.remove(heldFireball);
        camera.remove(rightArm);
        swordGroup=null; heldFireball=null; rightArm=null;
      }
      if (leftArm){
        if (shield) leftArm.remove(shield);
        camera.remove(leftArm);
        shield=null; leftArm=null;
      }
      if (iceWall){
        scene.remove(iceWall);
        objects = objects.filter(o=>o!==iceWall);
        iceWall=null;
      }
    }

    function createPlayerModel(className){
      const armGeometry = new THREE.BoxGeometry(0.4, 1.2, 0.4);
      const armMaterial = new THREE.MeshStandardMaterial({ color: 0xdeb887 });

      rightArm = new THREE.Mesh(armGeometry, armMaterial);
      rightArm.position.set(0.8, -0.7, -1.2);
      rightArm.rotation.set(-Math.PI/2.5, 0.3, -0.2);
      camera.add(rightArm);

      leftArm = new THREE.Mesh(armGeometry, armMaterial);
      leftArm.position.set(-0.8, -1.2, -1.2);
      leftArm.rotation.set(-Math.PI/2.5, -0.1, 0.2);
      camera.add(leftArm);

      if (className === 'warrior'){
        leftArm.visible = true;
        const blade = new THREE.Mesh(new THREE.BoxGeometry(0.05,1.5,0.2), new THREE.MeshStandardMaterial({ color:0xc0c0c0, metalness:0.8, roughness:0.4 }));
        blade.position.y = 0.75;
        const hilt = new THREE.Mesh(new THREE.BoxGeometry(0.15,0.4,0.15), new THREE.MeshStandardMaterial({ color:0x4a2c0f, roughness:0.8 }));
        const guard = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.5), new THREE.MeshStandardMaterial({ color:0xdaa520, metalness:0.6, roughness:0.5 }));
        guard.position.y = 0.25;
        swordGroup = new THREE.Group(); swordGroup.add(blade,hilt,guard);
        swordGroup.position.set(0,0.6,0); swordGroup.rotation.x = Math.PI/2.2;
        initialSwordRotation = swordGroup.rotation.clone();
        rightArm.add(swordGroup);

        const shieldWood = new THREE.Mesh(new THREE.BoxGeometry(1,1.5,0.2), new THREE.MeshStandardMaterial({ color:0x8B4513 }));
        const shieldIron = new THREE.Mesh(new THREE.BoxGeometry(1.1,1.6,0.1), new THREE.MeshStandardMaterial({ color:0x777777, metalness:0.7, roughness:0.6 }));
        shieldIron.position.z = -0.1;
        shield = new THREE.Group(); shield.add(shieldWood, shieldIron);
        shield.position.set(0,0.3,0.5); shield.rotation.y = -Math.PI/12; shield.rotation.x = Math.PI/3;
        leftArm.add(shield);
        initialLeftArmPosition = leftArm.position.clone();
        initialLeftArmRotation = leftArm.rotation.clone();

      } else if (className === 'mage'){
        leftArm.visible = false;
        const fireballGeometry = new THREE.SphereGeometry(0.2,16,16);
        const fireballMaterial = new THREE.MeshStandardMaterial({ color:0xff4500, emissive:0xff6600, emissiveIntensity:1.5 });
        heldFireball = new THREE.Mesh(fireballGeometry, fireballMaterial);
        const fireLight = new THREE.PointLight(0xff6600, 2, 5);
        heldFireball.add(fireLight);
        heldFireball.position.set(0,0.9,0.2);
        rightArm.add(heldFireball);
      }
    }

    function createWorld(){
      const floorGeometry = new THREE.PlaneGeometry(200,200);
      const floorMaterial = new THREE.MeshStandardMaterial({ color:0x228B22 });
      floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI/2; floor.receiveShadow = true;
      scene.add(floor); objects.push(floor);

      const house = new THREE.Group();
      const wallMaterial = new THREE.MeshStandardMaterial({ color:0xac8c6c });
      const wT=0.5, wH=5, wW=10, wD=12;

      const back = new THREE.Mesh(new THREE.BoxGeometry(wW,wH,wT), wallMaterial); back.position.set(0,wH/2,-wD/2); back.castShadow=true; house.add(back);
      const left = new THREE.Mesh(new THREE.BoxGeometry(wD,wH,wT), wallMaterial); left.position.set(-wW/2,wH/2,0); left.rotation.y = Math.PI/2; left.castShadow=true; house.add(left);
      const right = new THREE.Mesh(new THREE.BoxGeometry(wD,wH,wT), wallMaterial); right.position.set(wW/2,wH/2,0); right.rotation.y = Math.PI/2; right.castShadow=true; house.add(right);

      const doorW=3, doorH=4, sideW=(wW - doorW)/2;
      const frontL = new THREE.Mesh(new THREE.BoxGeometry(sideW,wH,wT), wallMaterial); frontL.position.set(-(doorW/2 + sideW/2), wH/2, wD/2); frontL.castShadow=true; house.add(frontL);
      const frontR = new THREE.Mesh(new THREE.BoxGeometry(sideW,wH,wT), wallMaterial); frontR.position.set((doorW/2 + sideW/2), wH/2, wD/2); frontR.castShadow=true; house.add(frontR);
      const frontT = new THREE.Mesh(new THREE.BoxGeometry(doorW, wH - doorH, wT), wallMaterial); frontT.position.set(0, doorH + (wH-doorH)/2, wD/2); frontT.castShadow=true; house.add(frontT);

      const roof = new THREE.Mesh(new THREE.ConeGeometry(wW*0.8,4,4), new THREE.MeshStandardMaterial({ color:0x8B4513 }));
      roof.position.set(0,wH+1.5,0); roof.rotation.y = Math.PI/4; roof.castShadow=true; house.add(roof);

      scene.add(house);
      objects.push(...house.children);

      const target = new THREE.Mesh(new THREE.BoxGeometry(1,2,1), new THREE.MeshStandardMaterial({ color:0xff0000 }));
      target.position.set(0,1,-8); target.name="target"; target.castShadow=true;
      scene.add(target); objects.push(target);
    }

    function updateHealthUI() {
        const hp = Math.max(0, playerHealth);
        healthBar.style.width = `${hp}%`;
        healthText.textContent = `${hp} HP`;
    }

    function takeDamage(amount) {
        if (playerHealth <= 0) return;
        playerHealth -= amount;
        updateHealthUI();
        if (playerHealth <= 0) {
            onDeath();
        }
    }

    function onDeath() {
        controls.unlock();
    }

    // ... (event listeners et fonctions de jeu)
    function onWindowResize(){ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

    function onKeyDown(e){
      switch(e.code){
        case 'KeyW': case 'KeyZ': moveForward = true; break;
        case 'KeyA': case 'KeyQ': moveLeft = true; break;
        case 'KeyS': moveBackward = true; break;
        case 'KeyD': moveRight = true; break;
        case 'Space': if (canJump) { playerVelocity.y += JUMP_VELOCITY; canJump=false; } break;
        case 'ShiftLeft': {
          const now = performance.now();
          if (playerClass === 'warrior'){
            if (now - lastDashTime > dashCooldown){ lastDashTime = now; isDashing = true; }
          } else if (playerClass === 'mage'){
            if (now - lastBlinkTime > blinkCooldown){ lastBlinkTime = now; performBlink(); }
          }
        } break;
      }
    }

    function onKeyUp(e){
      switch(e.code){
        case 'KeyW': case 'KeyZ': moveForward=false; break;
        case 'KeyA': case 'KeyQ': moveLeft=false; break;
        case 'KeyS': moveBackward=false; break;
        case 'KeyD': moveRight=false; break;
      }
    }

    function onMouseDown(e){
      if (!controls.isLocked) return;
      if (playerClass === 'warrior'){
        if (e.button===0 && !isAttacking && !isBlocking){
          const now = performance.now();
          if (now - lastAttackTime > attackCooldown){ isAttacking=true; lastAttackTime=now; swingSword(); }
        } else if (e.button===2 && !isBlocking){ raiseShield(); }
      } else if (playerClass === 'mage'){
        if (e.button===0){
          const now = performance.now();
          if (now - lastFireballTime > fireballCooldown){ lastFireballTime=now; castFireball(); }
        } else if (e.button===2){
          const now = performance.now();
          if (now - lastIceWallTime > iceWallCooldown){ lastIceWallTime=now; castIceWall(); }
        }
      }
    }

    function onMouseUp(e){ if (controls.isLocked && e.button===2 && playerClass==='warrior' && isBlocking) lowerShield(); }

    function performBlink(){
      const direction = new THREE.Vector3();
      const forward = Number(moveBackward) - Number(moveForward);
      const right = Number(moveRight) - Number(moveLeft);
      direction.z = forward; direction.x = right;
      if (direction.lengthSq() === 0) camera.getWorldDirection(direction);
      else direction.applyQuaternion(camera.quaternion);
      direction.y = 0; direction.normalize();
      const blinkVector = direction.multiplyScalar(BLINK_DISTANCE);
      controls.getObject().position.add(blinkVector);
    }

    function castIceWall(){
      if (iceWall) return;
      const wallGeometry = new THREE.BoxGeometry(8,5,0.5);
      const wallMaterial = new THREE.MeshStandardMaterial({ color:0xadd8e6, opacity:0.8, transparent:true, metalness:0.2, roughness:0.1 });
      iceWall = new THREE.Mesh(wallGeometry, wallMaterial); iceWall.name='iceWall';
      const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y=0; dir.normalize();
      const wallPos = controls.getObject().position.clone().add(dir.multiplyScalar(4)); wallPos.y = 2.5;
      iceWall.position.copy(wallPos);
      iceWall.lookAt(controls.getObject().position.x, 2.5, controls.getObject().position.z);
      scene.add(iceWall); objects.push(iceWall);

      iceWall.scale.set(1,0.01,1);
      const duration=200, start=performance.now();
      (function grow(){
        const t = Math.min((performance.now()-start)/duration,1);
        iceWall.scale.y = t;
        if (t<1) requestAnimationFrame(grow);
      })();

      setTimeout(destroyIceWall, iceWallDuration);
    }

    function destroyIceWall(){
      if (!iceWall) return;
      const duration=500, start=performance.now();
      (function fade(){
        const t = Math.min((performance.now()-start)/duration,1);
        if (iceWall){
          iceWall.material.opacity = 0.8 * (1-t);
          if (t<1) requestAnimationFrame(fade);
          else {
            scene.remove(iceWall);
            objects = objects.filter(o=>o!==iceWall);
            iceWall=null;
          }
        }
      })();
    }

    function castFireball(){
      if (!heldFireball) return;
      const projectile = heldFireball.clone();
      const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
      const startPos = new THREE.Vector3(); camera.getWorldPosition(startPos);
      projectile.position.copy(startPos).add(dir.clone().multiplyScalar(1.5));
      projectile.velocity = dir.normalize().multiplyScalar(35);
      projectile.lifetime = 3;
      scene.add(projectile);
      activeFireballs.push(projectile);
      heldFireball.visible = false;
      setTimeout(()=>{ if (heldFireball) heldFireball.visible = true; }, 200);
    }

    function swingSword(){
      if (!swordGroup) return;
      const targetX = 0;
      const duration=50, start=performance.now();
      (function swing(){
        const t = Math.min((performance.now()-start)/duration,1);
        swordGroup.rotation.x = initialSwordRotation.x + (targetX - initialSwordRotation.x) * t;
        if (t<1) requestAnimationFrame(swing);
        else { checkHit(); returnSword(); }
      })();
    }

    function returnSword(){
      if (!swordGroup) return;
      const fromX = swordGroup.rotation.x;
      const duration=75, start=performance.now();
      (function back(){
        const t = Math.min((performance.now()-start)/duration,1);
        swordGroup.rotation.x = fromX + (initialSwordRotation.x - fromX) * t;
        if (t<1) requestAnimationFrame(back);
        else { swordGroup.rotation.copy(initialSwordRotation); isAttacking=false; }
      })();
    }

    function raiseShield(){
      if (!leftArm || !leftArm.visible) return;
      isBlocking=true;
      const targetPos = new THREE.Vector3(-0.4,-1.1,-1.4);
      const startPos = leftArm.position.clone();
      const duration=100, start=performance.now();
      (function up(){
        if (!isBlocking) return;
        const t = Math.min((performance.now()-start)/duration,1);
        leftArm.position.lerpVectors(startPos, targetPos, t);
        if (t<1) requestAnimationFrame(up);
      })();
    }

    function lowerShield(){
      if (!leftArm || !leftArm.visible) return;
      const startPos = leftArm.position.clone();
      const duration=120, start=performance.now();
      (function down(){
        const t = Math.min((performance.now()-start)/duration,1);
        leftArm.position.lerpVectors(startPos, initialLeftArmPosition, t);
        if (t<1) requestAnimationFrame(down);
        else { leftArm.position.copy(initialLeftArmPosition); isBlocking=false; }
      })();
    }

    function checkHit(){
      const swordTip = new THREE.Vector3(0.6,-0.2,-2.5);
      const worldPos = swordTip.applyMatrix4(camera.matrixWorld);
      
      // Hit contre la cible d'entraînement
      const target = scene.getObjectByName('target');
      if (target && worldPos.distanceTo(target.position) < 1.5){
          target.material.color.set(0x00ff00);
          setTimeout(()=>target.material.color.set(0xff0000), 300);
      }
      
      // Hit contre les autres joueurs
      peerAvatars.forEach((avatar, id) => {
        const distance = worldPos.distanceTo(avatar.mesh.position);
        if (distance < 2.0) { // Rayon de l'attaque
            channel.send({ type: 'broadcast', event: 'hit', payload: { targetId: id, damage: 10 } });
        }
      });
    }

    function updateProjectiles(delta){
      for (let i=activeFireballs.length-1; i>=0; i--){
        const fb = activeFireballs[i];
        fb.position.add(fb.velocity.clone().multiplyScalar(delta));
        fb.lifetime -= delta;
        let remove = false;

        if (iceWall && (new THREE.Box3().setFromObject(iceWall)).intersectsBox(new THREE.Box3().setFromObject(fb))) {
            remove = true;
        }

        const target = scene.getObjectByName('target');
        if (target && fb.position.distanceTo(target.position) < 1.5){
          target.material.color.set(0x00ff00);
          setTimeout(()=>target.material.color.set(0xff0000), 300);
          remove = true;
        }
        
        peerAvatars.forEach((avatar, id) => {
            const avatarBB = new THREE.Box3().setFromObject(avatar.mesh);
            if (avatarBB.containsPoint(fb.position)) {
                channel.send({ type: 'broadcast', event: 'hit', payload: { targetId: id, damage: 10 } });
                remove = true;
            }
        });

        if (fb.lifetime <= 0) remove = true;
        if (remove){ scene.remove(fb); activeFireballs.splice(i,1); }
      }
    }

    function updatePlayer(delta){
      if (!controls.isLocked) return;

      playerDirection.z = Number(moveForward) - Number(moveBackward);
      playerDirection.x = Number(moveRight) - Number(moveLeft);

      if (isDashing){
        const dashDir = playerDirection.clone();
        if (dashDir.lengthSq()===0) dashDir.z = 1;
        dashDir.normalize();
        playerVelocity.z -= dashDir.z * DASH_STRENGTH;
        playerVelocity.x -= dashDir.x * DASH_STRENGTH;
        isDashing = false;
      }

      const speedDelta = PLAYER_SPEED * delta;
      playerVelocity.x -= playerVelocity.x * 5.0 * delta;
      playerVelocity.z -= playerVelocity.z * 5.0 * delta;

      playerDirection.normalize();
      if (moveForward || moveBackward) playerVelocity.z -= playerDirection.z * speedDelta;
      if (moveLeft || moveRight)      playerVelocity.x -= playerDirection.x * speedDelta;

      const playerCollider = new THREE.Box3();
      const playerSize = new THREE.Vector3(0.8, PLAYER_HEIGHT, 0.8);
      const originalPosition = controls.getObject().position.clone();

      controls.moveRight(-playerVelocity.x * delta);
      controls.moveForward(-playerVelocity.z * delta);
      
      playerCollider.setFromCenterAndSize(controls.getObject().position, playerSize);
      for (const object of objects){
        if (object === floor || object.isGroup) continue; // On ignore le sol et les groupes (avatars) pour cette boucle
        const bb = new THREE.Box3().setFromObject(object);
        if (playerCollider.intersectsBox(bb)){
            controls.getObject().position.copy(originalPosition); // Reset si collision mur/objet
            playerVelocity.x = 0;
            playerVelocity.z = 0;
            break;
        }
      }
      
      // Collision entre joueurs
      peerAvatars.forEach(avatar => {
        const remoteCollider = new THREE.Box3().setFromObject(avatar.mesh);
        if(playerCollider.intersectsBox(remoteCollider)) {
            controls.getObject().position.copy(originalPosition);
             playerVelocity.x = 0;
            playerVelocity.z = 0;
        }
      });


      playerVelocity.y -= GRAVITY * delta;
      controls.getObject().position.y += playerVelocity.y * delta;
      if (controls.getObject().position.y < PLAYER_HEIGHT){
        playerVelocity.y = 0;
        controls.getObject().position.y = PLAYER_HEIGHT;
        canJump = true;
      }
    }

    function animate(){
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      if (playerClass && controls.isLocked) updatePlayer(delta);
      updateProjectiles(delta);

      peerAvatars.forEach((avatar, id) => {
          const data = peers.get(id);
          if (!data) return;
          const { pos, rot, action } = data;
          
          avatar.mesh.position.lerp(new THREE.Vector3(pos.x, pos.y - PLAYER_HEIGHT + 1.1, pos.z), 0.2);
          
          const euler = new THREE.Euler(rot.x, rot.y, rot.z, 'YXZ');
          const quaternion = new THREE.Quaternion().setFromEuler(euler);
          avatar.mesh.quaternion.slerp(quaternion, 0.2);

          if (action !== avatar.lastAction) {
              avatar.lastAction = action;
              if (data.playerClass === 'warrior') {
                  const shield = avatar.mesh.getObjectByName('shield');
                  if (shield) {
                      shield.position.z = action === 'block' ? 0.8 : 0.3;
                  }
              }
          }
      });


      const now = performance.now();
      if (channel && now - lastSend > 66 && controls.isLocked){
        lastSend = now;
        const p = controls.getObject().position;
        const r = camera.rotation;

        let currentAction = 'idle';
        if (isAttacking) currentAction = 'attack';
        else if (isBlocking) currentAction = 'block';

        channel.send({
          type: 'broadcast',
          event: 'state',
          payload: {
            id: myId,
            pos: { x: p.x, y: p.y, z: p.z },
            rot: { x: r.x, y: r.y, z: r.z },
            playerClass: playerClass,
            action: currentAction,
            hp: playerHealth
          }
        });
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>

