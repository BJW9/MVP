<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>First-Person Warrior MVP</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
        Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      background: #000;
    }
    #blocker {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      z-index: 10;
    }
    #instructions {
      width: 80%;
      max-width: 600px;
      text-align: center;
      color: #fff;
      background: rgba(20,20,20,0.9);
      padding: 20px;
      border-radius: 15px;
      border: 1px solid #444;
      cursor: default;
    }
    #instructions h2 {
      margin: 0;
      font-size: 2rem;
      color: #ffa500;
    }
    #instructions p {
      font-size: 1.1rem;
      line-height: 1.5;
    }
    .class-selection button {
      background: #ffa500;
      color: #000;
      border: none;
      padding: 15px 30px;
      font-size: 1.2rem;
      font-weight: bold;
      border-radius: 10px;
      cursor: pointer;
      margin: 10px;
      transition: background-color .2s, transform .2s;
    }
    .class-selection button:hover {
      background: #ffc864;
      transform: scale(1.05);
    }
    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 4px;
      height: 4px;
      background: #fff;
      border-radius: 50%;
      transform: translate(-50%,-50%);
      pointer-events: none;
      z-index: 9;
      mix-blend-mode: difference;
      display: none;
    }
    #health-bar-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 30px;
      background: rgba(0,0,0,0.5);
      border: 2px solid #fff;
      border-radius: 15px;
      display: none;
      z-index: 9;
    }
    #health-bar {
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, #ff4500, #ff8c00);
      border-radius: 12px;
      transition: width .2s ease-in-out;
    }
    #health-text {
      position: absolute;
      inset: 0;
      color: #fff;
      text-shadow: 1px 1px 2px #000;
      font-weight: bold;
      line-height: 30px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="blocker">
    <div id="instructions">
      <div id="menu-content">
        <!-- Le contenu du menu est généré dynamiquement -->
      </div>
    </div>
  </div>

  <div id="crosshair"></div>

  <div id="health-bar-container">
    <div id="health-bar"></div>
    <div id="health-text">100 HP</div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "@supabase/supabase-js": "https://esm.sh/@supabase/supabase-js@2"
      }
    }
  </script>

  <script type="module">
    import { createClient } from '@supabase/supabase-js';
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    // === Supabase ===
    const SUPABASE_URL = 'https://ywxeflymtbyorqcirqiq.supabase.co';
    const SUPABASE_ANON_KEY =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl3eGVmbHltdGJ5b3JxY2lycWlxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg2NzkzNDIsImV4cCI6MjA3NDI1NTM0Mn0.mCucqm8nJ_c-ZaPR6ZpxZhF9qaufrphk4lLNpho728Y';

    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    let channel = null;

    const myId = crypto.randomUUID();
    const peers = new Map();
    const peerAvatars = new Map();
    const replicatedObjects = new Map();

    function v3ToJSON(v){ return { x: v.x, y: v.y, z: v.z }; }
    function qToJSON(q){ return { x: q.x, y: q.y, z: q.z, w: q.w }; }
    function v3FromJSON(o){ return new THREE.Vector3(o.x, o.y, o.z); }
    function qFromJSON(o){ return new THREE.Quaternion(o.x, o.y, o.z, o.w); }
    function randomCode(){ return Math.random().toString(36).slice(2,6).toUpperCase(); }

    function createRemotePlayerAvatar(data) {
      const { pos, playerClass } = data;
      const avatarGroup = new THREE.Group();

      const skinMaterial = new THREE.MeshStandardMaterial({ color: 0xdeb887 });
      const darkMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

      const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), skinMaterial);
      const torso = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.4), darkMaterial);
      const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.0, 0.3), darkMaterial);
      leftLeg.position.set(-0.25, -1.1, 0);
      const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.0, 0.3), darkMaterial);
      rightLeg.position.set(0.25, -1.1, 0);

      const body = new THREE.Group();
      body.add(head, torso, leftLeg, rightLeg);
      avatarGroup.add(body);

      if (playerClass === 'warrior') {
        const armorMaterial = new THREE.MeshStandardMaterial({
          color: 0x777777, metalness: 0.8, roughness: 0.4
        });
        const helmet = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), armorMaterial);
        head.add(helmet);

        const chestplate = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.0, 0.5), armorMaterial);
        chestplate.position.y = 0.1;
        torso.add(chestplate);

        const pauldronGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const leftPauldron = new THREE.Mesh(pauldronGeo, armorMaterial);
        leftPauldron.position.set(-0.5, 0.4, 0);
        torso.add(leftPauldron);
        const rightPauldron = new THREE.Mesh(pauldronGeo, armorMaterial);
        rightPauldron.position.set(0.5, 0.4, 0);
        torso.add(rightPauldron);

        const sword = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 1.5, 0.2),
          new THREE.MeshStandardMaterial({ color: 0xc0c0c0 })
        );
        sword.name = 'sword';
        sword.position.set(0.8, 0.3, 0.1);
        sword.rotation.z = -Math.PI / 16;
        torso.add(sword);

        const shield = new THREE.Mesh(
          new THREE.BoxGeometry(0.8, 1.2, 0.2),
          new THREE.MeshStandardMaterial({ color: 0x8B4513 })
        );
        shield.name = 'shield';
        shield.position.set(-0.8, 0.1, 0.1);
        shield.rotation.z = Math.PI / 16;
        torso.add(shield);

      } else if (playerClass === 'mage') {
        const robeMaterial = new THREE.MeshStandardMaterial({ color: 0x4a0d6a });
        const hat = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.8, 8), robeMaterial);
        hat.position.y = 0.5;
        head.add(hat);
        const robe = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.8, 1.8, 8), robeMaterial);
        robe.position.y = -0.3;
        torso.add(robe);
      }

      avatarGroup.position.set(pos.x, pos.y - PLAYER_HEIGHT + 1.1, pos.z);
      scene.add(avatarGroup);
      objects.push(avatarGroup);

      return { mesh: avatarGroup, lastAction: 'idle', playerClass: data.playerClass };
    }

    async function joinRoom(code){
      peerAvatars.forEach(avatar => {
        scene.remove(avatar.mesh);
        objects = objects.filter(o => o !== avatar.mesh);
      });
      peerAvatars.clear();
      peers.clear();

      if (channel) await supabase.removeChannel(channel);

      channel = supabase.channel(`room:${code}`, { config: { presence: { key: myId } } });

      channel.on('presence', { event: 'join' }, ({ newPresences }) => {
        for (const pres of newPresences) {
          if (pres.key !== myId) {
            replicatedObjects.forEach(obj => {
              if (obj.ownerId === myId) {
                channel.send({
                  type: 'broadcast',
                  event: 'game_event',
                  payload: obj.getSpawnPayload()
                });
              }
            });
          }
        }
      });

      channel.on('presence', { event: 'leave' }, ({ leftPresences }) => {
        for (const pres of leftPresences) {
          const avatar = peerAvatars.get(pres.key);
          if (avatar) {
            scene.remove(avatar.mesh);
            objects = objects.filter(o => o !== avatar.mesh);
            peerAvatars.delete(pres.key);
          }
          peers.delete(pres.key);
        }
      });

      channel.on('broadcast', { event: 'hit' }, ({ payload }) => {
        if (payload.targetId === myId) takeDamage(payload.damage);
      });

      channel.on('broadcast', { event: 'game_event' }, ({ payload }) => {
        if (payload.ownerId === myId) return;
        handleGameEvent(payload);
      });

      channel.on('broadcast', { event: 'state' }, ({ payload }) => {
        const { id, pos, rot, playerClass, action } = payload;
        if (id === myId) return;

        peers.set(id, { pos, rot, playerClass, action });

        const existingAvatar = peerAvatars.get(id);
        if (existingAvatar && existingAvatar.playerClass !== playerClass) {
          scene.remove(existingAvatar.mesh);
          objects = objects.filter(o => o !== existingAvatar.mesh);
          const newAvatar = createRemotePlayerAvatar({ pos, playerClass });
          peerAvatars.set(id, newAvatar);
        } else if (!existingAvatar) {
          const newAvatar = createRemotePlayerAvatar({ pos, playerClass });
          peerAvatars.set(id, newAvatar);
        }
      });

      await channel.subscribe((status) => {
        if (status === 'SUBSCRIBED') channel.track({ id: myId, joinedAt: Date.now() });
      });
    }

    window.addEventListener('pagehide', async () => {
      try { if (channel) await supabase.removeChannel(channel); } catch {}
    });

    // === Three.js / jeu ===
    let scene, camera, renderer, controls;
    let playerVelocity = new THREE.Vector3();
    let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false, canJump=false;
    let objects = [];
    let playerClass = null;
    let playerHealth = 100;

    let isAttacking=false, lastAttackTime=0, isBlocking=false, isDashing=false, lastDashTime=0;
    const attackCooldown=100, dashCooldown=1500;
    let lastFireballTime=0, heldFireball=null;
    const fireballCooldown=1000, iceWallCooldown=10000, blinkCooldown=3000;
    let lastIceWallTime=0, lastBlinkTime=0;

    let swordGroup, rightArm, leftArm, shield, floor;
    let initialSwordRotation, initialLeftArmPosition, initialLeftArmRotation;

    const PLAYER_SPEED=8.0, PLAYER_HEIGHT=1.8, GRAVITY=30.0, JUMP_VELOCITY=10.0, DASH_STRENGTH=20.0, BLINK_DISTANCE=8.0;
    const DECELERATION_TIME = 0.5;

    const clock = new THREE.Clock();
    const crosshair = document.getElementById('crosshair');
    const healthBarContainer = document.getElementById('health-bar-container');
    const healthBar = document.getElementById('health-bar');
    const healthText = document.getElementById('health-text');

    let lastSend = 0;

    init();
    animate();

    function init(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 0, 100);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.y = PLAYER_HEIGHT;

      renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
      dirLight.position.set(-50,50,50);
      dirLight.castShadow = true;
      dirLight.shadow.camera.top=20;
      dirLight.shadow.camera.bottom=-20;
      dirLight.shadow.camera.left=-20;
      dirLight.shadow.camera.right=20;
      scene.add(dirLight);

      controls = new PointerLockControls(camera, document.body);
      const blocker = document.getElementById('blocker');

      buildMainMenu();

      blocker.addEventListener('click', (event) => {
        if (event.target === blocker && playerClass) controls.lock();
      });

      controls.addEventListener('lock', () => {
        blocker.style.display = 'none';
        crosshair.style.display = 'block';
        healthBarContainer.style.display = 'block';
      });

      controls.addEventListener('unlock', () => {
        blocker.style.display = 'flex';
        crosshair.style.display = 'none';
        healthBarContainer.style.display = 'none';
        buildMainMenu(playerHealth <= 0);
      });

      document.addEventListener('pointerlockerror', () => console.error('Pointer Lock Error'), false);

      scene.add(controls.getObject());
      createWorld();

      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      document.addEventListener('mousedown', onMouseDown);
      document.addEventListener('mouseup', onMouseUp);
      window.addEventListener('resize', onWindowResize);
      document.addEventListener('contextmenu', (e)=>e.preventDefault());
    }

    function buildMainMenu(isDeath = false) {
      const menuContent = document.getElementById('menu-content');
      const title = isDeath ? "Vous êtes mort." : "Menu Principal";
      const subtitle = isDeath ? "Choisissez une classe pour réapparaître." : "Choisissez votre classe ou rejoignez une partie.";

      menuContent.innerHTML = `
        <h2>${title}</h2>
        <p>${subtitle}</p>
        <div class="class-selection">
          <button id="btnWarrior">Guerrier</button>
          <button id="btnMage">Mage</button>
        </div>
        <div style="margin-top:12px">
          <input id="roomCode" placeholder="Code de room (ex: ABCD)" maxlength="12" />
          <button id="btnCreate">Créer</button>
          <button id="btnJoin">Rejoindre</button>
        </div>
        <p style="margin-top:20px;">Appuyez sur Échap pour retourner au jeu.</p>
      `;

      setupMenuListeners();
      setupRoomListeners();
    }

    function setupMenuListeners(){
      document.getElementById('btnWarrior').addEventListener('click', (e)=>selectClass(e,'warrior'));
      document.getElementById('btnMage').addEventListener('click', (e)=>selectClass(e,'mage'));
    }

    function setupRoomListeners(){
      const roomInput = document.getElementById('roomCode');

      document.getElementById('btnCreate').addEventListener('click', async (e)=>{
        e.stopPropagation();
        const code = (roomInput.value || randomCode()).toUpperCase();
        await joinRoom(code);
        if(!playerClass) alert('Veuillez choisir une classe avant de commencer.');
        else alert(`Room créée: ${code}`);
      });

      document.getElementById('btnJoin').addEventListener('click', async (e)=>{
        e.stopPropagation();
        const code = (roomInput.value || '').toUpperCase();
        if (!code) return alert('Entre un code de room.');
        await joinRoom(code);
        if(!playerClass) alert('Veuillez choisir une classe avant de commencer.');
        else alert(`Rejoint room: ${code}`);
      });
    }

    function selectClass(event, chosenClass){
      event.stopPropagation();
      playerClass = chosenClass;
      playerHealth = 100;
      updateHealthUI();
      cleanupPlayerModel();
      createPlayerModel(playerClass);

      controls.getObject().position.set(0, PLAYER_HEIGHT, 5);
      playerVelocity.set(0,0,0);

      const menuContent = document.getElementById('menu-content');
      menuContent.innerHTML = `
        <h2>Classe : ${chosenClass === 'warrior' ? 'Guerrier' : 'Mage'}</h2>
        <p style="font-size:1.5rem; margin-top:30px;">Cliquez pour commencer</p>
      `;
    }

    function cleanupPlayerModel(){
      if (rightArm){
        if (swordGroup) rightArm.remove(swordGroup);
        if (heldFireball) rightArm.remove(heldFireball);
        camera.remove(rightArm);
        swordGroup=null; heldFireball=null; rightArm=null;
      }
      if (leftArm){
        if (shield) leftArm.remove(shield);
        camera.remove(leftArm);
        shield=null; leftArm=null;
      }
      
      replicatedObjects.forEach((obj, id) => {
        if (obj.ownerId === myId) {
          const payload = { eventType: 'destroy', objectId: id, ownerId: myId };
          handleGameEvent(payload);
          if (channel) channel.send({ type: 'broadcast', event: 'game_event', payload });
        }
      });
    }

    function createPlayerModel(className){
      const armGeometry = new THREE.BoxGeometry(0.4, 1.2, 0.4);
      const armMaterial = new THREE.MeshStandardMaterial({ color: 0xdeb887 });

      rightArm = new THREE.Mesh(armGeometry, armMaterial);
      rightArm.position.set(0.8, -0.7, -1.2);
      rightArm.rotation.set(-Math.PI/2.5, 0.3, -0.2);
      camera.add(rightArm);

      leftArm = new THREE.Mesh(armGeometry, armMaterial);
      leftArm.position.set(-0.8, -1.2, -1.2);
      leftArm.rotation.set(-Math.PI/2.5, -0.1, 0.2);
      camera.add(leftArm);

      if (className === 'warrior'){
        leftArm.visible = true;

        const blade = new THREE.Mesh(
          new THREE.BoxGeometry(0.05,1.5,0.2),
          new THREE.MeshStandardMaterial({ color:0xc0c0c0, metalness:0.8, roughness:0.4 })
        );
        blade.position.y = 0.75;

        const hilt = new THREE.Mesh(
          new THREE.BoxGeometry(0.15,0.4,0.15),
          new THREE.MeshStandardMaterial({ color:0x4a2c0f, roughness:0.8 })
        );

        const guard = new THREE.Mesh(
          new THREE.BoxGeometry(0.1,0.1,0.5),
          new THREE.MeshStandardMaterial({ color:0xdaa520, metalness:0.6, roughness:0.5 })
        );
        guard.position.y = 0.25;

        swordGroup = new THREE.Group();
        swordGroup.add(blade,hilt,guard);
        swordGroup.position.set(0,0.6,0);
        swordGroup.rotation.x = Math.PI/2.2;
        initialSwordRotation = swordGroup.rotation.clone();
        rightArm.add(swordGroup);

        const shieldWood = new THREE.Mesh(
          new THREE.BoxGeometry(1,1.5,0.2),
          new THREE.MeshStandardMaterial({ color:0x8B4513 })
        );
        const shieldIron = new THREE.Mesh(
          new THREE.BoxGeometry(1.1,1.6,0.1),
          new THREE.MeshStandardMaterial({ color:0x777777, metalness:0.7, roughness:0.6 })
        );
        shieldIron.position.z = -0.1;

        shield = new THREE.Group();
        shield.add(shieldWood, shieldIron);
        shield.position.set(0,0.3,0.5);
        shield.rotation.y = -Math.PI/12;
        shield.rotation.x = Math.PI/3;
        leftArm.add(shield);

        initialLeftArmPosition = leftArm.position.clone();
        initialLeftArmRotation = leftArm.rotation.clone();

      } else if (className === 'mage'){
        leftArm.visible = false;

        const fireballGeometry = new THREE.SphereGeometry(0.2,16,16);
        const fireballMaterial = new THREE.MeshStandardMaterial({
          color:0xff4500, emissive:0xff6600, emissiveIntensity:1.5
        });
        heldFireball = new THREE.Mesh(fireballGeometry, fireballMaterial);
        const fireLight = new THREE.PointLight(0xff6600, 2, 5);
        heldFireball.add(fireLight);
        heldFireball.position.set(0,0.9,0.2);
        rightArm.add(heldFireball);
      }
    }

    function createWorld(){
      const floorGeometry = new THREE.PlaneGeometry(200,200);
      const floorMaterial = new THREE.MeshStandardMaterial({ color:0x228B22 });
      floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI/2;
      floor.receiveShadow = true;
      scene.add(floor);
      objects.push(floor);

      const house = new THREE.Group();
      const wallMaterial = new THREE.MeshStandardMaterial({ color:0xac8c6c });
      const wT=0.5, wH=5, wW=10, wD=12;

      const back = new THREE.Mesh(new THREE.BoxGeometry(wW,wH,wT), wallMaterial);
      back.position.set(0,wH/2,-wD/2);
      back.castShadow=true;
      house.add(back);

      const left = new THREE.Mesh(new THREE.BoxGeometry(wD,wH,wT), wallMaterial);
      left.position.set(-wW/2,wH/2,0);
      left.rotation.y = Math.PI/2;
      left.castShadow=true;
      house.add(left);

      const right = new THREE.Mesh(new THREE.BoxGeometry(wD,wH,wT), wallMaterial);
      right.position.set(wW/2,wH/2,0);
      right.rotation.y = Math.PI/2;
      right.castShadow=true;
      house.add(right);

      const doorW=3, doorH=4, sideW=(wW - doorW)/2;
      const frontL = new THREE.Mesh(new THREE.BoxGeometry(sideW,wH,wT), wallMaterial);
      frontL.position.set(-(doorW/2 + sideW/2), wH/2, wD/2);
      frontL.castShadow=true;
      house.add(frontL);

      const frontR = new THREE.Mesh(new THREE.BoxGeometry(sideW,wH,wT), wallMaterial);
      frontR.position.set((doorW/2 + sideW/2), wH/2, wD/2);
      frontR.castShadow=true;
      house.add(frontR);

      const frontT = new THREE.Mesh(new THREE.BoxGeometry(doorW, wH - doorH, wT), wallMaterial);
      frontT.position.set(0, doorH + (wH-doorH)/2, wD/2);
      frontT.castShadow=true;
      house.add(frontT);

      const roof = new THREE.Mesh(
        new THREE.ConeGeometry(wW*0.8,4,4),
        new THREE.MeshStandardMaterial({ color:0x8B4513 })
      );
      roof.position.set(0,wH+1.5,0);
      roof.rotation.y = Math.PI/4;
      roof.castShadow=true;
      house.add(roof);

      scene.add(house);
      objects.push(...house.children);

      const target = new THREE.Mesh(
        new THREE.BoxGeometry(1,2,1),
        new THREE.MeshStandardMaterial({ color:0xff0000 })
      );
      target.position.set(0,1,-8);
      target.name="target";
      target.castShadow=true;
      scene.add(target);
      objects.push(target);
    }

    function updateHealthUI() {
      const hp = Math.max(0, playerHealth);
      healthBar.style.width = `${hp}%`;
      healthText.textContent = `${hp} HP`;
    }

    function takeDamage(amount) {
      if (playerHealth <= 0 || (playerClass === 'warrior' && isBlocking)) return;
      playerHealth -= amount;
      updateHealthUI();
      if (playerHealth <= 0) onDeath();
    }

    function onDeath() { controls.unlock(); }

    function onWindowResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(e){
      switch(e.code){
        case 'KeyW': case 'KeyZ': moveForward = true; break;
        case 'KeyA': case 'KeyQ': moveLeft = true; break;
        case 'KeyS': moveBackward = true; break;
        case 'KeyD': moveRight = true; break;
        case 'Space':
          if (canJump) { playerVelocity.y += JUMP_VELOCITY; canJump=false; }
          break;
        case 'ShiftLeft': {
          const now = performance.now();
          if (playerClass === 'warrior'){
            if (now - lastDashTime > dashCooldown){ lastDashTime = now; isDashing = true; }
          } else if (playerClass === 'mage'){
            if (now - lastBlinkTime > blinkCooldown){ lastBlinkTime = now; performBlink(); }
          }
        } break;
      }
    }

    function onKeyUp(e){
      switch(e.code){
        case 'KeyW': case 'KeyZ': moveForward=false; break;
        case 'KeyA': case 'KeyQ': moveLeft=false; break;
        case 'KeyS': moveBackward=false; break;
        case 'KeyD': moveRight=false; break;
      }
    }

    function onMouseDown(e){
      if (!controls.isLocked) return;

      if (playerClass === 'warrior'){
        if (e.button===0 && !isAttacking && !isBlocking){
          const now = performance.now();
          if (now - lastAttackTime > attackCooldown){
            isAttacking=true; lastAttackTime=now; swingSword();
          }
        } else if (e.button===2 && !isBlocking){
          raiseShield();
        }
      } else if (playerClass === 'mage'){
        const now = performance.now();
        if (e.button===0){
          if (now - lastFireballTime > fireballCooldown){
            lastFireballTime=now; castFireball();
          }
        } else if (e.button===2){
          if (now - lastIceWallTime > iceWallCooldown){
            lastIceWallTime=now; castIceWall();
          }
        }
      }
    }

    function onMouseUp(e){
      if (controls.isLocked && e.button===2 && playerClass==='warrior' && isBlocking) lowerShield();
    }

    function performBlink(){
      const direction = new THREE.Vector3();
      const forward = Number(moveBackward) - Number(moveForward);
      const right = Number(moveRight) - Number(moveLeft);
      direction.z = forward;
      direction.x = right;

      if (direction.lengthSq() === 0) camera.getWorldDirection(direction);
      else direction.applyQuaternion(camera.quaternion);

      direction.y = 0;
      direction.normalize();

      const blinkVector = direction.multiplyScalar(BLINK_DISTANCE);
      controls.getObject().position.add(blinkVector);
    }

    function handleGameEvent(payload) {
      const { eventType, objectId, objectType, data, ownerId } = payload;

      switch (eventType) {
        case 'spawn': {
          if (replicatedObjects.has(objectId)) return;

          let newObject;

          if (objectType === 'iceWall') {
            const wallGeometry = new THREE.BoxGeometry(8, 5, 0.5);
            const wallMaterial = new THREE.MeshStandardMaterial({
              color: 0xadd8e6,
              opacity: 0.0,
              transparent: true,
              metalness: 0.2,
              roughness: 0.1
            });
            newObject = new THREE.Mesh(wallGeometry, wallMaterial);
            newObject.name = 'iceWall';
            newObject.position.copy(v3FromJSON(data.position));
            newObject.quaternion.copy(qFromJSON(data.quaternion));
            animateWallIn(newObject, 0.8, 300);

          } else if (objectType === 'fireball') {
            const fireballGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const fireballMaterial = new THREE.MeshStandardMaterial({
              color: 0xff4500,
              emissive: 0xff6600,
              emissiveIntensity: 1.5
            });
            newObject = new THREE.Mesh(fireballGeometry, fireballMaterial);
            newObject.position.copy(v3FromJSON(data.position));
            newObject.velocity = v3FromJSON(data.velocity);
          }

          if (newObject) {
            newObject.ownerId = ownerId;
            newObject.getSpawnPayload = () => ({
              eventType: 'spawn',
              objectId, objectType, ownerId, data
            });

            scene.add(newObject);
            objects.push(newObject);
            replicatedObjects.set(objectId, newObject);

            if (data.lifetime && ownerId === myId) {
              setTimeout(() => {
                const destroyPayload = { eventType: 'destroy', objectId, ownerId: myId };
                handleGameEvent(destroyPayload);
                if (channel) channel.send({ type:'broadcast', event:'game_event', payload: destroyPayload });
              }, data.lifetime);
            }
          }
          break;
        }

        case 'destroy': {
          destroyReplicatedObject(objectId);
          break;
        }
      }
    }

    function animateWallIn(mesh, targetOpacity, duration){
      const start = performance.now();
      const startOpacity = mesh.material.opacity;
      const startScaleY = mesh.scale.y;
      const endScaleY = 1;

      function tick(){
        const t = Math.min((performance.now() - start) / duration, 1);
        mesh.material.opacity = startOpacity + (targetOpacity - startOpacity) * t;
        mesh.scale.y = startScaleY + (endScaleY - startScaleY) * t;
        if (t < 1) requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    }
    
    function destroyReplicatedObject(objectId) {
      if (!replicatedObjects.has(objectId)) return;
      const obj = replicatedObjects.get(objectId);

      const duration=500, start=performance.now();
      (function fade(){
        const t = Math.min((performance.now()-start)/duration,1);
        if(obj.material && obj.material.opacity !== undefined)
          obj.material.opacity = (obj.material.opacity || 1) * (1-t);
        if (t<1) requestAnimationFrame(fade);
        else {
          scene.remove(obj);
          objects = objects.filter(o => o !== obj);
          replicatedObjects.delete(objectId);
        }
      })();
    }

    function castIceWall(){
      const wallId = `icewall-${myId}-${Date.now()}`;

      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir); dir.y = 0; dir.normalize();

      const wallPos = controls.getObject().position.clone().add(dir.clone().multiplyScalar(4));
      const wallY = 2.5;
      wallPos.y = wallY;

      const tmp = new THREE.Object3D();
      tmp.position.copy(wallPos);
      tmp.lookAt(controls.getObject().position.x, wallY, controls.getObject().position.z);

      const lifetime = 5000;

      const payload = {
        eventType: 'spawn',
        objectId: wallId,
        objectType: 'iceWall',
        ownerId: myId,
        data: {
          position: v3ToJSON(tmp.position),
          quaternion: qToJSON(tmp.quaternion),
          lifetime
        }
      };

      handleGameEvent(payload);
      if (channel) channel.send({ type:'broadcast', event:'game_event', payload });
    }

    function castFireball(){
      if (!heldFireball) return;

      const projectileId = `fireball-${myId}-${Date.now()}`;
      const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
      const startPos = new THREE.Vector3(); camera.getWorldPosition(startPos);
      const position = startPos.add(dir.clone().multiplyScalar(1.5));
      const velocity = dir.normalize().multiplyScalar(35);

      const payload = {
        eventType: 'spawn',
        objectId: projectileId,
        objectType: 'fireball',
        ownerId: myId,
        data: {
          position: v3ToJSON(position),
          velocity: v3ToJSON(velocity),
          lifetime: 3000
        }
      };

      handleGameEvent(payload);
      if (channel) channel.send({ type: 'broadcast', event: 'game_event', payload });

      heldFireball.visible = false;
      setTimeout(()=>{ if (heldFireball) heldFireball.visible = true; }, 200);
    }

    function swingSword(){
      if (!swordGroup) return;
      const targetX = 0;
      const duration=50, start=performance.now();
      (function swing(){
        const t = Math.min((performance.now()-start)/duration,1);
        swordGroup.rotation.x = initialSwordRotation.x + (targetX - initialSwordRotation.x) * t;
        if (t<1) requestAnimationFrame(swing);
        else { checkHit(); returnSword(); }
      })();
    }

    function returnSword(){
      if (!swordGroup) return;
      const fromX = swordGroup.rotation.x;
      const duration=75, start=performance.now();
      (function back(){
        const t = Math.min((performance.now()-start)/duration,1);
        swordGroup.rotation.x = fromX + (initialSwordRotation.x - fromX) * t;
        if (t<1) requestAnimationFrame(back);
        else { swordGroup.rotation.copy(initialSwordRotation); isAttacking=false; }
      })();
    }

    function raiseShield(){
      if (!leftArm || !leftArm.visible) return;
      isBlocking=true;
      const targetPos = new THREE.Vector3(-0.4,-1.1,-1.4);
      const startPos = leftArm.position.clone();
      const duration=100, start=performance.now();
      (function up(){
        if (!isBlocking) return;
        const t = Math.min((performance.now()-start)/duration,1);
        leftArm.position.lerpVectors(startPos, targetPos, t);
        if (t<1) requestAnimationFrame(up);
      })();
    }

    function lowerShield(){
      if (!leftArm || !leftArm.visible) return;
      const startPos = leftArm.position.clone();
      const duration=120, start=performance.now();
      (function down(){
        const t = Math.min((performance.now()-start)/duration,1);
        leftArm.position.lerpVectors(startPos, initialLeftArmPosition, t);
        if (t<1) requestAnimationFrame(down);
        else { leftArm.position.copy(initialLeftArmPosition); isBlocking=false; }
      })();
    }

    function checkHit(){
      const swordTip = new THREE.Vector3(0.6,-0.2,-2.5);
      const worldPos = swordTip.applyMatrix4(camera.matrixWorld);

      const target = scene.getObjectByName('target');
      if (target && worldPos.distanceTo(target.position) < 1.5){
        target.material.color.set(0x00ff00);
        setTimeout(()=>target.material.color.set(0xff0000), 300);
      }

      peerAvatars.forEach((avatar, id) => {
        const distance = worldPos.distanceTo(avatar.mesh.position);
        if (distance < 2.0) {
          channel.send({ type: 'broadcast', event: 'hit', payload: { targetId: id, damage: 10 } });
        }
      });
    }

    function updateProjectiles(delta){
      replicatedObjects.forEach((obj, id) => {
        if (!obj.velocity) return;

        obj.position.add(obj.velocity.clone().multiplyScalar(delta));
        let remove = false;

        replicatedObjects.forEach(otherObj => {
          if (otherObj.name === 'iceWall') {
            const wallBB = new THREE.Box3().setFromObject(otherObj);
            const projBB = new THREE.Box3().setFromObject(obj);
            if (wallBB.intersectsBox(projBB)) remove = true;
          }
        });

        const target = scene.getObjectByName('target');
        if (target && obj.position.distanceTo(target.position) < 1.5){
          target.material.color.set(0x00ff00);
          setTimeout(()=>target.material.color.set(0xff0000), 300);
          remove = true;
        }

        peerAvatars.forEach((avatar, peerId) => {
          if (obj.ownerId === peerId) return;
          const avatarBB = new THREE.Box3().setFromObject(avatar.mesh);
          if (avatarBB.containsPoint(obj.position)) {
            if (obj.ownerId === myId) {
              channel.send({ type: 'broadcast', event: 'hit', payload: { targetId: peerId, damage: 10 } });
            }
            remove = true;
          }
        });

        const playerCollider = new THREE.Box3().setFromCenterAndSize(
          controls.getObject().position,
          new THREE.Vector3(0.8, PLAYER_HEIGHT, 0.8)
        );
        if(playerCollider.containsPoint(obj.position) && obj.ownerId !== myId) {
          takeDamage(10);
          remove = true;
        }

        if (remove && obj.ownerId === myId){
          const payload = { eventType: 'destroy', objectId: id, ownerId: myId };
          handleGameEvent(payload);
          channel.send({ type: 'broadcast', event: 'game_event', payload });
        }
      });
    }

    function updatePlayer(delta){
      if (playerVelocity.y !== 0 || !canJump) {
        playerVelocity.y -= GRAVITY * delta;
        controls.getObject().position.y += playerVelocity.y * delta;
      }
      if (controls.getObject().position.y < PLAYER_HEIGHT) {
        playerVelocity.y = 0;
        controls.getObject().position.y = PLAYER_HEIGHT;
        canJump = true;
      }

      if (!controls.isLocked) return;

      const moveDirection = new THREE.Vector3(
        Number(moveRight) - Number(moveLeft), 0,
        Number(moveBackward) - Number(moveForward)
      );

      const deceleration = (PLAYER_SPEED / DECELERATION_TIME) * delta;

      if (moveDirection.lengthSq() === 0) {
        const speed = Math.sqrt(playerVelocity.x * playerVelocity.x + playerVelocity.z * playerVelocity.z);
        if (speed > deceleration) {
          playerVelocity.x -= (playerVelocity.x / speed) * deceleration;
          playerVelocity.z -= (playerVelocity.z / speed) * deceleration;
        } else {
          playerVelocity.x = 0;
          playerVelocity.z = 0;
        }
      } else {
        moveDirection.normalize().multiplyScalar(PLAYER_SPEED);
        playerVelocity.x = moveDirection.x;
        playerVelocity.z = moveDirection.z;
      }

      if (isDashing){
        const dashImpulse = new THREE.Vector3(
          (Number(moveRight) - Number(moveLeft)), 0,
          (Number(moveBackward) - Number(moveForward))
        );
        if(dashImpulse.lengthSq() === 0) dashImpulse.z = -1;
        dashImpulse.applyQuaternion(camera.quaternion).normalize();
        controls.getObject().position.add(dashImpulse.multiplyScalar(DASH_STRENGTH * delta));
        isDashing = false;
      }

      const finalMove = new THREE.Vector3(playerVelocity.x, 0, playerVelocity.z).applyQuaternion(camera.quaternion);

      const originalPosition = controls.getObject().position.clone();
      const newPosition = originalPosition.clone();

      const step = finalMove.clone().multiplyScalar(delta);

      // Collision X
      newPosition.x += step.x;
      let playerCollider = new THREE.Box3().setFromCenterAndSize(newPosition, new THREE.Vector3(0.8, PLAYER_HEIGHT, 0.8));
      let collidedX = false;
      for (const object of objects) {
        if (object === floor || object.isGroup) continue;
        if (playerCollider.intersectsBox(new THREE.Box3().setFromObject(object))) { collidedX = true; break; }
      }
      peerAvatars.forEach(avatar => {
        if (playerCollider.intersectsBox(new THREE.Box3().setFromObject(avatar.mesh))) {
          collidedX = true;
        }
      });
      if (collidedX) newPosition.x = originalPosition.x;

      // Collision Z
      newPosition.z += step.z;
      playerCollider.setFromCenterAndSize(newPosition, new THREE.Vector3(0.8, PLAYER_HEIGHT, 0.8));
      let collidedZ = false;
      for (const object of objects) {
        if (object === floor || object.isGroup) continue;
        if (playerCollider.intersectsBox(new THREE.Box3().setFromObject(object))) { collidedZ = true; break; }
      }
      peerAvatars.forEach(avatar => {
        if (playerCollider.intersectsBox(new THREE.Box3().setFromObject(avatar.mesh))) {
          collidedZ = true;
        }
      });
      if (collidedZ) newPosition.z = originalPosition.z;

      controls.getObject().position.copy(newPosition);
    }

    function animate(){
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      if (playerClass) updatePlayer(delta);
      updateProjectiles(delta);

      peerAvatars.forEach((avatar, id) => {
        const data = peers.get(id);
        if (!data) return;
        const { pos, rot, action } = data;

        avatar.mesh.position.lerp(new THREE.Vector3(pos.x, pos.y - PLAYER_HEIGHT + 1.1, pos.z), 0.2);

        const euler = new THREE.Euler(0, rot.y, 0, 'YXZ');
        const quaternion = new THREE.Quaternion().setFromEuler(euler);
        avatar.mesh.quaternion.slerp(quaternion, 0.2);

        if (action !== avatar.lastAction) {
          avatar.lastAction = action;
          if (data.playerClass === 'warrior') {
            const shield = avatar.mesh.getObjectByName('shield');
            if (shield) shield.position.z = action === 'block' ? 0.8 : 0.3;
          }
        }
      });

      const now = performance.now();
      if (channel && now - lastSend > 66 && playerClass){
        lastSend = now;
        const p = controls.getObject().position;
        const r = camera.rotation;

        let currentAction = 'idle';
        if (isAttacking) currentAction = 'attack';
        else if (isBlocking) currentAction = 'block';

        channel.send({
          type: 'broadcast',
          event: 'state',
          payload: {
            id: myId,
            pos: { x: p.x, y: p.y, z: p.z },
            rot: { x: r.x, y: r.y, z: r.z },
            playerClass: playerClass,
            action: currentAction,
            hp: playerHealth
          }
        });
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>

